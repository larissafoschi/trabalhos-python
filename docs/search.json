[
  {
    "objectID": "posts/welcome.html",
    "href": "posts/welcome.html",
    "title": "Welcome to my first blog!",
    "section": "",
    "text": "Este é meu blog Quarto, onde compartilho projetos, análises de dados e estudos sobre programação e tecnologia.\n\n\n\n\nProjetos de programação: códigos, scripts e visualizações.\nAnálises de dados: gráficos, mapas e insights interessantes.\n\n\n\n\nUse o menu no topo para acessar diferentes seções, ou explore os posts mais recentes logo abaixo. Sinta-se à vontade para comentar e compartilhar suas ideias!\nSinta-se à vontade para explorar os posts no menu ou abaixo!"
  },
  {
    "objectID": "posts/welcome.html#o-que-você-vai-encontrar-por-aqui",
    "href": "posts/welcome.html#o-que-você-vai-encontrar-por-aqui",
    "title": "Welcome to my first blog!",
    "section": "",
    "text": "Projetos de programação: códigos, scripts e visualizações.\nAnálises de dados: gráficos, mapas e insights interessantes."
  },
  {
    "objectID": "posts/welcome.html#como-navegar",
    "href": "posts/welcome.html#como-navegar",
    "title": "Welcome to my first blog!",
    "section": "",
    "text": "Use o menu no topo para acessar diferentes seções, ou explore os posts mais recentes logo abaixo. Sinta-se à vontade para comentar e compartilhar suas ideias!\nSinta-se à vontade para explorar os posts no menu ou abaixo!"
  },
  {
    "objectID": "posts/2025-11-22-cot_dolarr.html",
    "href": "posts/2025-11-22-cot_dolarr.html",
    "title": "Cotação do Dólar por Período",
    "section": "",
    "text": "Introdução\nNesta atividade foi desenvolvida uma rotina em Python que recebe como entrada um mês e um ano no formato MMYYYY e consulta a API do Banco Central para obter a cotação diária do dólar frente ao real naquele período.\nO objetivo é:\n\nidentificar o primeiro e o último dia do mês automaticamente\nconsultar a API do Banco Central\norganizar os dados em formato de tabela\npreencher dias sem cotação (como fins de semana e feriados)\nexibir um gráfico de linha interativo utilizando a biblioteca Plotly\n\n\n\n\nBibliotecas utilizadas\nimport requests\nimport pandas as pd\nimport plotly.express as px\nimport calendar\nfrom datetime import datetime, timedelta\nrequests: realiza a consulta HTTP na API do Banco Central\npandas: organiza os dados em tabela\nplotly.express: cria o gráfico interativo\ncalendar e datetime: manipulam datas\n\n\nLógica da função\n\nConversão da data\n\nA função recebe uma string no formato MMYYYY e converte para uma data do tipo datetime, representando o primeiro dia do mês:\nprimeira_data = datetime.strptime(mes_ano, \"%m%Y\")\n\nDescobrindo o último dia do mês\n\nO Python calcula automaticamente quantos dias existem no mês informado:\nultimo_dia = calendar.monthrange(primeira_data.year, primeira_data.month)[1]\nultima_data = primeira_data.replace(day=ultimo_dia)\n\nFormatação para a API\n\nA API do Banco Central exige datas no padrão MM-DD-YYYY, portanto elas são formatadas:\ndata_inicial = primeira_data.strftime(\"%m-%d-%Y\")\ndata_final   = ultima_data.strftime(\"%m-%d-%Y\")\n\nConstrução da URL\n\nA URL da consulta é montada com os parâmetros necessários:\nurl = (\n    f\"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n    f\"CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?\"\n    f\"@dataInicial='{data_inicial}'&@dataFinalCotacao='{data_final}'\"\n    f\"&$top=1000&$format=json\"\n    f\"&$select=cotacaoCompra,cotacaoVenda,dataHoraCotacao\"\n)\n\nConsulta e tratamento dos dados\n\nApós a requisição, os dados são transformados em DataFrame:\ndf = pd.DataFrame(resposta[\"value\"])\nA coluna de data é transformada para remover o horário e facilitar a ordenação:\ndf[\"dataHoraCotacao\"] = pd.to_datetime(df[\"dataHoraCotacao\"]).dt.date\ndf = df.sort_values(\"dataHoraCotacao\")\n\nPreenchendo dias sem cotação\n\nAlguns dias, como finais de semana e feriados, não possuem valores retornados pela API. Para manter a continuidade da linha do gráfico, é utilizado o valor do último dia útil anterior:\ndf_completo[\"cotacaoVenda\"] = df_completo[\"cotacaoVenda\"].fillna(method=\"ffill\")\n\nGeração do gráfico\n\nPor fim, o gráfico interativo é exibido com Plotly:\nfig = px.line(\n    df_completo,\n    x=\"dataHoraCotacao\",\n    y=\"cotacaoVenda\",\n    title=f\"Cotação do Dólar – {mes_ano[:2]}/{mes_ano[2:]}\",\n    labels={\n        \"dataHoraCotacao\": \"Data\",\n        \"cotacaoVenda\": \"Cotação de Venda (R$)\"\n    },\n    markers=True\n)\n\nfig.show()\n\n\n\nCÓDIGO COMPLETO\nimport requests\nimport pandas as pd\nimport plotly.express as px\nimport calendar\nfrom datetime import datetime, timedelta\n\ndef grafico_cotacao_dolar(mes_ano: str):\n\n    primeira_data = datetime.strptime(mes_ano, \"%m%Y\")\n\n    ultimo_dia = calendar.monthrange(primeira_data.year, primeira_data.month)[1]\n    ultima_data = primeira_data.replace(day=ultimo_dia)\n\n    data_inicial = primeira_data.strftime(\"%m-%d-%Y\")\n    data_final   = ultima_data.strftime(\"%m-%d-%Y\")\n\n    url = (\n        f\"https://olinda.bcb.gov.br/olinda/servico/PTAX/versao/v1/odata/\"\n        f\"CotacaoDolarPeriodo(dataInicial=@dataInicial,dataFinalCotacao=@dataFinalCotacao)?\"\n        f\"@dataInicial='{data_inicial}'&amp;@dataFinalCotacao='{data_final}'\"\n        f\"&amp;$top=1000&amp;$format=json\"\n        f\"&amp;$select=cotacaoCompra,cotacaoVenda,dataHoraCotacao\"\n    )\n\n    resposta = requests.get(url).json()\n\n    if \"value\" not in resposta or not resposta[\"value\"]:\n        print(\"Nenhuma cotação encontrada para esse período.\")\n        return\n\n    df = pd.DataFrame(resposta[\"value\"])\n\n    df[\"dataHoraCotacao\"] = pd.to_datetime(df[\"dataHoraCotacao\"]).dt.date\n\n    df = df.sort_values(\"dataHoraCotacao\")\n\n    todas_as_datas = pd.date_range(\n        start=primeira_data,\n        end=ultima_data\n    ).date\n\n    df_completo = pd.DataFrame({\"dataHoraCotacao\": todas_as_datas})\n\n    df_completo = df_completo.merge(\n        df[[\"dataHoraCotacao\", \"cotacaoVenda\"]],\n        on=\"dataHoraCotacao\",\n        how=\"left\"\n    )\n\n    df_completo[\"cotacaoVenda\"] = df_completo[\"cotacaoVenda\"].fillna(method=\"ffill\")\n\n    fig = px.line(\n        df_completo,\n        x=\"dataHoraCotacao\",\n        y=\"cotacaoVenda\",\n        title=f\"Cotação do Dólar – {mes_ano[:2]}/{mes_ano[2:]}\",\n        labels={\n            \"dataHoraCotacao\": \"Data\",\n            \"cotacaoVenda\": \"Cotação de Venda (R$)\"\n        },\n        markers=True\n    )\n\n    fig.show()\n\n    return df_completo\n\ngrafico_cotacao_dolar(\"062023\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programação-Python",
    "section": "",
    "text": "Welcome to my first blog!\n\n\n\n\n\n\n\n\nJan 1, 2099\n\n\nLarissa Foschi\n\n\n\n\n\n\n\n\n\n\n\n\nCotação do Dólar por Período\n\n\n\n\n\n\n\n\nNov 22, 2025\n\n\nLarissa Foschi\n\n\n\n\n\n\n\n\n\n\n\n\nMonitoramento de Frota de Ônibus\n\n\n\n\n\n\n\n\nNov 21, 2025\n\n\nLarissa Foschi\n\n\n\n\n\n\n\n\n\n\n\n\nRegressão Linear – Estimativa de Salário\n\n\n\n\n\n\n\n\nNov 21, 2025\n\n\nLarissa Foschi\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/2025-11-21-onibus.html",
    "href": "posts/2025-11-21-onibus.html",
    "title": "Monitoramento de Frota de Ônibus",
    "section": "",
    "text": "Introdução\nNesta atividade foi desenvolvida uma rotina em Python para monitorar em tempo real a posição dos ônibus de uma linha específica utilizando a API pública da SPTrans (Olho Vivo).\nO objetivo foi:\n\nautenticar na API utilizando um token pessoal\nbuscar as paradas de uma linha escolhida\nobter a posição atual dos veículos em circulação\nexibir tudo em um mapa interativo, destacando:\n\nparadas (em azul)\nônibus em movimento (em vermelho)\n\n\n\n\n\nBibliotecas utilizadas\n\nrequests: para fazer as chamadas HTTP na API da SPTrans\ndotenv: para ler o token armazenado no arquivo .env\nfolium: responsável pela construção do mapa interativo\nos: manipulação de variáveis do sistema\n\n\n\n\nAutenticação na API\nAntes de consultar qualquer informação, o código realiza o login na API usando o token fornecido no .env:\nimport os\nimport requests\nfrom dotenv import load_dotenv\n\n\nload_dotenv(\".env\")\n\ns = requests.Session()\nres = s.post(\n    f\"http://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token={os.getenv('SPTRANS_TOKEN')}\"\n)\nprint(res.text)\nSe a autenticação estiver correta, a resposta será \"true\".\n\nConsulta da linha\n\nCom a sessão autenticada, é feita a busca de linhas que contenham o termo “Lapa”:\nlinhas_lapa = s.get(\n    \"http://api.olhovivo.sptrans.com.br/v2.1/Linha/Buscar?termosBusca=Lapa\"\n)\n\nlinhas_lapa = linhas_lapa.json()\nprint(linhas_lapa[:3])\nApós isso, escolheu-se uma linha específica pelo código: \nres = s.get(\n    \"http://api.olhovivo.sptrans.com.br/v2.1/Parada/BuscarParadasPorLinha?codigoLinha=35274\"\n)\n\nparadas = res.json()\nprint(paradas)\n\nObtendo posição dos ônibus em tempo real\n\nO próximo passo foi obter os veículos que estão circulando naquele momento:\npos_res = s.get(\n    f\"http://api.olhovivo.sptrans.com.br/v2.1/Posicao/Linha?codigoLinha=35274\"\n)\npos = pos_res.json()\n\nif isinstance(pos, dict) and pos.get(\"vs\"):\n    print(f\"Foram encontrados {len(pos['vs'])} ônibus circulando.\")\nelse:\n    print(\"Nenhum ônibus em movimento no momento.\")\n\nConstrução do mapa\n\nA API retorna as coordenadas (latitude e longitude) tanto das paradas quanto dos veículos. Usando o folium, um mapa foi gerado contendo:\nmarcadores azuis → paradas\nmarcadores vermelhos → ônibus em trânsito\nfrom folium import Map, Marker, Icon\nfrom paradas import paradas\nfrom posicoes import pos\n\nm = Map(location=[paradas[0][\"py\"], paradas[0][\"px\"]], zoom_start=13)\n\nfor p in paradas:\n    Marker(\n        location=[p[\"py\"], p[\"px\"]],\n        popup=f\"Parada: {p['np']}\",\n        icon=Icon(color=\"blue\", icon=\"bus\", prefix=\"fa\")\n    ).add_to(m)\n\nif \"vs\" in pos and pos[\"vs\"]:\n    for v in pos[\"vs\"]:\n        Marker(\n            location=[v[\"py\"], v[\"px\"]],\n            popup=f\"Ônibus {v['p']} - sentido {v['a']}\",\n            icon=Icon(color=\"red\", icon=\"info-sign\")\n        ).add_to(m)\n\nm.show_in_browser()\nO resultado é um mapa interativo exibido no navegador, permitindo visualizar a estrutura da linha e onde os veículos estão em tempo real.\n\n\n\nCÓDIGO COMPLETO\n\nMapas:\n\nfrom folium import Map, Marker, Icon\nfrom paradas import paradas\nfrom posicoes import pos\n\nm = Map(location=[paradas[0][\"py\"], paradas[0][\"px\"]], zoom_start=13)\n\nfor p in paradas:\n    Marker(\n        location=[p[\"py\"], p[\"px\"]],\n        popup=f\"Parada: {p['np']}\",\n        icon=Icon(color=\"blue\", icon=\"bus\", prefix=\"fa\")\n    ).add_to(m)\n\nif \"vs\" in pos and pos[\"vs\"]:\n    for v in pos[\"vs\"]:\n        Marker(\n            location=[v[\"py\"], v[\"px\"]],\n            popup=f\"Ônibus {v['p']} - sentido {v['a']}\",\n            icon=Icon(color=\"red\", icon=\"info-sign\")\n        ).add_to(m)\n\nm.show_in_browser()\n\nParadas:\n\nimport os\nimport requests\nfrom dotenv import load_dotenv\n\nload_dotenv(\".env\")\n\ns = requests.Session()\nres = s.post(\nf\"http://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token={os.getenv('SPTRANS_TOKEN')}\"\n)\n\nprint(res.text)\n\nlinhas_lapa = s.get(\n\"http://api.olhovivo.sptrans.com.br/v2.1/Linha/Buscar?termosBusca=Lapa\"\n)\n\nlinhas_lapa = linhas_lapa.json()\nprint(linhas_lapa[:3])\n\nres = s.get(\n\"http://api.olhovivo.sptrans.com.br/v2.1/Parada/BuscarParadasPorLinha?codigoLinha=35274\"\n)\n\nparadas = res.json()\nprint(paradas)\n\nPosições dos ônibus:\n\nimport os\nimport requests\nfrom dotenv import load_dotenv\n\nload_dotenv(\".env\")\n\nTOKEN = os.getenv(\"SPTRANS_TOKEN\")\nCODIGO_LINHA = os.getenv(\"SPTRANS_CODIGO_LINHA\", \"35274\")\n\nif not TOKEN:\n    raise RuntimeError(\"SPTRANS_TOKEN não definido em .env\")\n\ns = requests.Session()\nlogin_res = s.post(f\"http://api.olhovivo.sptrans.com.br/v2.1/Login/Autenticar?token={TOKEN}\")\nif not login_res.ok or login_res.text.strip().lower() != \"true\":\n    raise RuntimeError(f\"Falha ao autenticar: {login_res.status_code} {login_res.text}\")\n\npos_res = s.get(f\"http://api.olhovivo.sptrans.com.br/v2.1/Posicao/Linha?codigoLinha={CODIGO_LINHA}\")\npos_res.raise_for_status()\n\npos = pos_res.json()\n\nif isinstance(pos, dict) and pos.get(\"vs\"):\n    print(f\"Foram encontrados {len(pos['vs'])} ônibus circulando.\")\nelse:\n    print(\"Nenhum ônibus em movimento no momento.\")\nprint(pos)"
  },
  {
    "objectID": "posts/2025-11-23-reg_linear.html",
    "href": "posts/2025-11-23-reg_linear.html",
    "title": "Regressão Linear – Estimativa de Salário",
    "section": "",
    "text": "Introdução\nNesta atividade foi realizada uma análise de regressão linear simples para estudar a relação entre:\n\nX → anos de estudo\n\ny → salário\n\nOs valores foram carregados a partir de dois arquivos de texto (X.txt e y.txt).\nO objetivo foi:\n\nmontar a função de regressão linear usando cálculo matricial\ngerar os coeficientes da reta estimada\nrepresentar graficamente os pontos reais e a reta calculada utilizando a biblioteca Plotly\n\n\n\n\nBibliotecas utilizadas\n\nnumpy: para operações de vetores e matrizes\nplotly.graph_objects: para criar o gráfico interativo da regressão\n\n\n\nCarregando os dados\n\nOs valores de X e y foram carregados utilizando numpy.loadtxt, que lê os arquivos .txt e os converte para arrays numéricos:\nX = np.loadtxt(\"X.txt\")\ny = np.loadtxt(\"y.txt\")\n\nMontando a matriz do modelo\n\nEm regressão linear, o modelo matemático é:\nŷ = a + bX\nPara calcular a e b por álgebra linear, é necessário montar a matriz X_matrix contendo:\nprimeira coluna: valores iguais a 1 (para representar o termo constante a)\nsegunda coluna: os valores reais de X\nX_matrix = np.column_stack((np.ones(len(X)), X))\n\nCálculo dos coeficientes\n\nO vetor de coeficientes é dado pela fórmula matricial clássica da regressão:\nβ = (XᵀX)⁻¹ Xᵀy\nOnde β contém:\nβ₀ (intercepto)\nβ₁ (inclinação)\nbeta = np.linalg.inv(X_matrix.T @ X_matrix) @ (X_matrix.T @ y)\na = beta[0]\nb = beta[1]\nAo final deste passo, a e b são os parâmetros da reta que melhor se ajusta aos dados.\n\nCalculando valores estimados\n\nDepois de estimar os coeficientes, foram gerados valores da reta para fins de visualização:\nx_line = np.linspace(X.min(), X.max(), 200)\ny_line = a + b * x_line\nIsso permite traçar uma linha contínua cobrindo toda a faixa de valores observados.\n\nGráfico com Plotly\n\nO gráfico final contém:\n- Pontos reais observados (dados dos arquivos)\n\n- Reta da regressão ajustada\nfig = go.Figure()\n\nfig.add_trace(go.Scatter(\n    x=X, y=y, mode=\"markers\",\n    name=\"Dados observados\"\n))\n\nfig.add_trace(go.Scatter(\n    x=x_line, y=y_line, mode=\"lines\",\n    name=\"Regressão linear\"\n))\n\nfig.update_layout(\n    title=\"Regressão Linear com Plotly\",\n    xaxis_title=\"x (anos de estudo)\",\n    yaxis_title=\"y (salário)\"\n)\n\nfig.show()\n\n\n\nCÓDIGO COMPLETO\nimport numpy as np\nimport plotly.graph_objects as go\n \nX = np.loadtxt(\"X.txt\")\ny = np.loadtxt(\"y.txt\")\n \nX_matrix = np.column_stack((np.ones(len(X)), X))\n\nbeta = np.linalg.inv(X_matrix.T @ X_matrix) @ (X_matrix.T @ y)\na = beta[0]   # intercepto\nb = beta[1]   # inclinação\n \nprint(\"Coeficientes:\")\nprint(\"a =\", a)\nprint(\"b =\", b)\n \nx_line = np.linspace(X.min(), X.max(), 200)\ny_line = a + b * x_line\n \nfig = go.Figure()\n \nfig.add_trace(go.Scatter(\n    x=X, y=y, mode=\"markers\",\n    name=\"Dados observados\"\n))\n \nfig.add_trace(go.Scatter(\n    x=x_line, y=y_line, mode=\"lines\",\n    name=\"Regressão linear\"\n))\n \nfig.update_layout(\n    title=\"Regressão Linear com Plotly\",\n    xaxis_title=\"x (anos de estudo)\",\n    yaxis_title=\"y (salário)\"\n)\n \nfig.show()"
  }
]